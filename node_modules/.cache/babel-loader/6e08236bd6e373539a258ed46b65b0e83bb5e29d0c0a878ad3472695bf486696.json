{"ast":null,"code":"import { Position } from \"../enums/Position\";\nexport class Player {\n  //TODO: implement (optional) player number, if the field was filled out on creation, then display that info.\n  //otherwise, auto-increment the player id starting from the lowest available number on the current team\n\n  //  id:number;\n  //TODO use mongoDB for player ids, like i did for chess games\n\n  constructor(name, playerType, currentPosition) {\n    this.name = void 0;\n    this.playerType = void 0;\n    this.currentPosition = void 0;\n    this.onCourt = false;\n    this.playerLink = void 0;\n    this.serve = true;\n    this.num = void 0;\n    //todo: figure out currentPosition value, is it like player number? or is it like, rotation location?\n    this.name = name;\n    this.playerType = playerType;\n    this.currentPosition = currentPosition;\n  }\n\n  /**\n   * hasPlayerLink defines a substitution connection between this player and a different player. The Position type of the player object\n   * will be used to determine what occurs when this player rotates/transitions between the front and back rows\n   */\n  hasPlayerLink() {\n    return this.playerLink !== undefined;\n  }\n  setName(name) {\n    this.name = name;\n  }\n  getName() {\n    return this.name;\n  }\n  setPlayerType(playerType) {\n    this.playerType = playerType;\n  }\n  getPlayerType() {\n    return this.playerType;\n  }\n\n  //rotation position\n  setCurrentPosition(currentPosition) {\n    this.currentPosition = currentPosition;\n  }\n  getCurrentPosition() {\n    return this.currentPosition;\n  }\n  setOnCourt(onCourt) {\n    this.onCourt = onCourt;\n  }\n  isInRotation() {\n    return this.onCourt;\n  }\n  setServe(willServe) {\n    this.serve = willServe;\n  }\n  isServing() {\n    return this.serve;\n  }\n  getPlayerLink() {\n    return this.playerLink;\n  }\n  setPlayerLink(player) {\n    this.playerLink = player;\n  }\n  getNumber() {\n    return this.num;\n  }\n  setNumber(num) {\n    this.num = num;\n  }\n  setPlayerNumber(num, providedByUser) {\n    this.num = num;\n    this.numberProvided = providedByUser;\n  }\n  toString() {\n    return JSON.stringify(this);\n  }\n  static revive(playerToRevive) {\n    return this.reviveRecursive(playerToRevive, false);\n  }\n  static reviveRecursive(playerToRevive, isPlayerLink) {\n    let revivedPosition = Position.revive(playerToRevive.playerType);\n    let revivedPlayer = new Player(playerToRevive.name, revivedPosition, playerToRevive.currentPosition);\n    revivedPlayer.setOnCourt(playerToRevive.onCourt);\n    revivedPlayer.setNumber(playerToRevive.num);\n    revivedPlayer.setServe(playerToRevive.serve);\n    if (!isPlayerLink && playerToRevive.playerLink !== undefined) {\n      revivedPlayer.setPlayerLink(this.reviveRecursive(playerToRevive.playerLink, true));\n    }\n    return revivedPlayer;\n  }\n}","map":{"version":3,"names":["Position","Player","constructor","name","playerType","currentPosition","onCourt","playerLink","serve","num","hasPlayerLink","undefined","setName","getName","setPlayerType","getPlayerType","setCurrentPosition","getCurrentPosition","setOnCourt","isInRotation","setServe","willServe","isServing","getPlayerLink","setPlayerLink","player","getNumber","setNumber","setPlayerNumber","providedByUser","numberProvided","toString","JSON","stringify","revive","playerToRevive","reviveRecursive","isPlayerLink","revivedPosition","revivedPlayer"],"sources":["/Users/adamhayes/RotationHelper/src/components/Player.tsx"],"sourcesContent":["import { Position } from \"../enums/Position\";\n\nexport class Player {\n    name: String;\n    playerType: Position;\n    currentPosition: number;\n    onCourt: boolean = false;\n    playerLink: Player;\n    serve: boolean = true;\n    num:number;\n\n    //TODO: implement (optional) player number, if the field was filled out on creation, then display that info.\n    //otherwise, auto-increment the player id starting from the lowest available number on the current team\n\n\n    //  id:number;\n    //TODO use mongoDB for player ids, like i did for chess games\n\n    constructor(name: String, playerType: Position, currentPosition: number) {\n        //todo: figure out currentPosition value, is it like player number? or is it like, rotation location?\n        this.name = name;\n        this.playerType = playerType;\n        this.currentPosition = currentPosition;\n    }\n\n\n    /**\n     * hasPlayerLink defines a substitution connection between this player and a different player. The Position type of the player object\n     * will be used to determine what occurs when this player rotates/transitions between the front and back rows\n     */\n    public hasPlayerLink(): boolean {\n        return this.playerLink !== undefined;\n    }\n\n    public setName(name: String) {\n        this.name = name;\n    }\n    public getName(): String {\n        return this.name;\n    }\n\n    public setPlayerType(playerType: Position) {\n        this.playerType = playerType;\n    }\n\n    public getPlayerType(): Position {\n        return this.playerType;\n    }\n\n\n    //rotation position\n    public setCurrentPosition(currentPosition: number) {\n        this.currentPosition = currentPosition;\n    }\n\n    public getCurrentPosition(): number {\n        return this.currentPosition;\n    }\n\n    public setOnCourt(onCourt: boolean) {\n        this.onCourt = onCourt;\n    }\n\n    public isInRotation(): boolean {\n        return this.onCourt;\n    }\n\n    public setServe(willServe: boolean) {\n        this.serve = willServe;\n    }\n\n    public isServing(): boolean {\n        return this.serve;\n    }\n\n    public getPlayerLink():Player | undefined {\n        return this.playerLink;\n    }\n\n    public setPlayerLink(player:Player)\n    {\n        this.playerLink = player;\n    }\n\n    public getNumber():number {\n        return this.num;\n    }\n\n    public setNumber(num:number) {\n        this.num = num;\n    }\n\n    public setPlayerNumber(num:number, providedByUser:boolean)\n    {\n        this.num = num;\n        this.numberProvided = providedByUser;\n    }\n\n    public toString():string {\n        return JSON.stringify(this);\n    }\n\n\n    public static revive(playerToRevive:Player):Player {\n\n        return this.reviveRecursive(playerToRevive, false);\n    }\n\n    private static reviveRecursive(playerToRevive:Player, isPlayerLink:boolean):Player\n    {\n        let revivedPosition = Position.revive(playerToRevive.playerType);\n        let revivedPlayer = new Player(playerToRevive.name, revivedPosition, playerToRevive.currentPosition);\n        revivedPlayer.setOnCourt(playerToRevive.onCourt);\n        revivedPlayer.setNumber(playerToRevive.num);\n        revivedPlayer.setServe(playerToRevive.serve);\n        if (!isPlayerLink && playerToRevive.playerLink !== undefined) {\n            revivedPlayer.setPlayerLink(this.reviveRecursive(playerToRevive.playerLink, true));\n        }\n        return revivedPlayer;\n    }\n\n\n\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}