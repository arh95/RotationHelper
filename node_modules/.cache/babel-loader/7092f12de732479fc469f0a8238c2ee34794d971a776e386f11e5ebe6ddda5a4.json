{"ast":null,"code":"import{useRef,useState}from'react';import{Source}from'../enums/Source';import{Position}from'../enums/Position';import Button from'@mui/material/Button';import'./RosterWidget.css';import AddPlayerModal from'./AddPlayerModal';import PlayerWidget from'./PlayerWidget';import{jsx as _jsx,jsxs as _jsxs}from\"react/jsx-runtime\";function Roster(){const[rosterList,setRosterList]=useState(new Array());const[showAddPlayerModal,setShowAddPlayerModal]=useState(false);const nextValidPlayerNumber=useRef(1);//TODO: add collapse/expand roster section controls (introduce accordion panel?)\nfunction sortRosterList(list){list.sort((a,b)=>a.getNumber()-b.getNumber());return list;}//this function is intended to run after a player has been created but BEFORE that player gets assigned a number and added to the roster list\nfunction generatePlayerNumber(){if(rosterList.length===0){//if no other players are in the roster list, then we can start at 1 for the player number\nreturn 1;}else{console.log(\"iterating through existing players to find their number\");let rosterListCopy=[];for(let player of rosterList){rosterListCopy.push(player);}rosterListCopy=sortRosterList(rosterListCopy);let lowestAvailableNumber=1;for(let i=0;i<rosterListCopy.length;i++){if(rosterListCopy[i].getNumber()===lowestAvailableNumber){lowestAvailableNumber++;}else{//if in the array sorted by player number, we find a Player whose number does not equal our incremental\n//tracker, that means that we can use our tracker's value as the number\nreturn lowestAvailableNumber;}}//if we reach the end of the array without finding a number that is free for use, use the incremented value which \n//should not be present in the array\nreturn lowestAvailableNumber;}}function addPlayerToRoster(newPlayer){newPlayer.setNumber(generatePlayerNumber());let rosterListCopy=[];Position.getValidPositions().forEach(position=>{console.log(position.getLabel);let playersOfType=[];for(let player of rosterList){if(player.getPlayerType().key==position.key){playersOfType.push(player);}}if(newPlayer.getPlayerType()==position){console.log(\"MATCH in position type\");playersOfType.push(newPlayer);}rosterListCopy=rosterListCopy.concat(playersOfType);});console.log(rosterListCopy);// rosterListCopy = sortRosterList(rosterListCopy);\nsetRosterList(rosterListCopy);displayAddPlayerModal(false);}//TODO: detection function to make sure that auto increment of player numbers goes smoothly, and takes into account team members that already exist\nfunction displayAddPlayerModal(showModal){setShowAddPlayerModal(showModal);}function resetAddPlayerModal(){}return/*#__PURE__*/_jsxs(\"div\",{className:\"RosterWidget\",children:[/*#__PURE__*/_jsx(\"div\",{className:\"RosterDisplay\",children:rosterList.filter(player=>!player.isOnCourt()).map((player,index)=>/*#__PURE__*/_jsx(PlayerWidget,{player:player,source:Source.ROSTER},player.getNumber()))}),/*#__PURE__*/_jsx(Button,{id:\"showModal\",onClick:()=>displayAddPlayerModal(true),children:\"Add Player\"}),/*#__PURE__*/_jsx(AddPlayerModal,{isOpen:showAddPlayerModal,cancelAction:value=>{displayAddPlayerModal(value);},submitAction:value=>{addPlayerToRoster(value);}})]});}export default Roster;","map":{"version":3,"names":["useRef","useState","Source","Position","Button","AddPlayerModal","PlayerWidget","jsx","_jsx","jsxs","_jsxs","Roster","rosterList","setRosterList","Array","showAddPlayerModal","setShowAddPlayerModal","nextValidPlayerNumber","sortRosterList","list","sort","a","b","getNumber","generatePlayerNumber","length","console","log","rosterListCopy","player","push","lowestAvailableNumber","i","addPlayerToRoster","newPlayer","setNumber","getValidPositions","forEach","position","getLabel","playersOfType","getPlayerType","key","concat","displayAddPlayerModal","showModal","resetAddPlayerModal","className","children","filter","isOnCourt","map","index","source","ROSTER","id","onClick","isOpen","cancelAction","value","submitAction"],"sources":["/Users/adamhayes/RotationHelper/src/components/RosterWidget.tsx"],"sourcesContent":["import { MutableRefObject, useRef, useState } from 'react';\nimport { Player } from './Player';\nimport { Source } from '../enums/Source';\nimport { Position } from '../enums/Position';\nimport Button from '@mui/material/Button';\n\nimport './RosterWidget.css';\nimport AddPlayerModal from './AddPlayerModal';\nimport PlayerWidget from './PlayerWidget';\n\nfunction Roster() {\n\n    const [rosterList, setRosterList] = useState(new Array<Player>());\n    const [showAddPlayerModal, setShowAddPlayerModal] = useState(false);\n    const nextValidPlayerNumber: MutableRefObject<number> = useRef(1);\n\n    //TODO: add collapse/expand roster section controls (introduce accordion panel?)\n\n    function sortRosterList(list: Player[]): Player[] {\n        list.sort((a: Player, b: Player) => a.getNumber() - b.getNumber());\n        return list;\n    }\n\n    //this function is intended to run after a player has been created but BEFORE that player gets assigned a number and added to the roster list\n    function generatePlayerNumber(): number {\n        if (rosterList.length === 0) {\n            //if no other players are in the roster list, then we can start at 1 for the player number\n            return 1;\n        }\n        else {\n            console.log(\"iterating through existing players to find their number\");\n            let rosterListCopy: Player[] = [];\n            for (let player of rosterList) {\n                rosterListCopy.push(player);\n            }\n            rosterListCopy = sortRosterList(rosterListCopy);\n            let lowestAvailableNumber: number = 1;\n            for (let i = 0; i < rosterListCopy.length; i++) {\n                if (rosterListCopy[i].getNumber() === lowestAvailableNumber) {\n                    lowestAvailableNumber++;\n                }\n                else {\n                    //if in the array sorted by player number, we find a Player whose number does not equal our incremental\n                    //tracker, that means that we can use our tracker's value as the number\n                    return lowestAvailableNumber;\n                }\n            }\n            //if we reach the end of the array without finding a number that is free for use, use the incremented value which \n            //should not be present in the array\n            return lowestAvailableNumber;\n        }\n    }\n\n\n\nfunction addPlayerToRoster(newPlayer: Player) {\n\n\n    newPlayer.setNumber(generatePlayerNumber());\n    let rosterListCopy: Player[] = [];\n    Position.getValidPositions().forEach((position) => {\n        console.log(position.getLabel);\n        let playersOfType: Player[] = [];\n        for (let player of rosterList) {\n            if (player.getPlayerType().key == position.key) {\n                playersOfType.push(player);\n            }\n        }\n        if (newPlayer.getPlayerType() == position) {\n            console.log(\"MATCH in position type\");\n            playersOfType.push(newPlayer);\n        }\n        rosterListCopy = rosterListCopy.concat(playersOfType);\n    });\n    console.log(rosterListCopy);\n    // rosterListCopy = sortRosterList(rosterListCopy);\n    setRosterList(rosterListCopy);\n    displayAddPlayerModal(false);\n}\n\n//TODO: detection function to make sure that auto increment of player numbers goes smoothly, and takes into account team members that already exist\n\nfunction displayAddPlayerModal(showModal: boolean) {\n    setShowAddPlayerModal(showModal);\n}\n\nfunction resetAddPlayerModal() {\n\n}\n\n\n\n\n\nreturn (\n    <div className=\"RosterWidget\">\n\n        <div className='RosterDisplay'>\n\n            {rosterList.filter((player: Player) => !player.isOnCourt()).map((player: Player, index) => (\n                <PlayerWidget key={player.getNumber()} player={player} source={Source.ROSTER} />\n            ))}\n        </div>\n        <Button id='showModal' onClick={() => displayAddPlayerModal(true)}>\n            Add Player\n        </Button>\n        <AddPlayerModal isOpen={showAddPlayerModal} cancelAction={(value: boolean) => { displayAddPlayerModal(value) }} submitAction={(value: Player) => { addPlayerToRoster(value) }} />\n    </div>\n);\n}\n\nexport default Roster;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}