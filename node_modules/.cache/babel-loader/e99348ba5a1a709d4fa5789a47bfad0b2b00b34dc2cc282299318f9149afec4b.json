{"ast":null,"code":"import{Position}from\"../enums/Position\";export class Player{//TODO: implement (optional) player number, if the field was filled out on creation, then display that info.\n//otherwise, auto-increment the player id starting from the lowest available number on the current team\n//  id:number;\n//TODO use mongoDB for player ids, like i did for chess games\nconstructor(name,playerType,currentPosition){this.name=void 0;this.playerType=void 0;this.currentPosition=void 0;this.usedInRotation=false;this.playerLink=void 0;this.serve=true;this.num=void 0;this.numberProvided=false;//todo: figure out currentPosition value, is it like player number? or is it like, rotation location?\nthis.name=name;this.playerType=playerType;this.currentPosition=currentPosition;}/**\n     * hasPlayerLink defines a substitution connection between this player and a different player. The Position type of the player object\n     * will be used to determine what occurs when this player rotates/transitions between the front and back rows\n     */hasPlayerLink(){return this.playerLink!==undefined;}setName(name){this.name=name;}getName(){return this.name;}setPlayerType(playerType){this.playerType=playerType;}getPlayerType(){return this.playerType;}//rotation position\nsetCurrentPosition(currentPosition){this.currentPosition=currentPosition;}getCurrentPosition(){return this.currentPosition;}setInRotation(value){this.usedInRotation=value;}isInRotation(){return this.usedInRotation;}setServe(willServe){this.serve=willServe;}isServing(){return this.serve;}getPlayerLink(){return this.playerLink;}setPlayerLink(player){this.playerLink=player;}getNumber(){return this.num;}setNumber(num){this.num=num;}setPlayerNumber(num,providedByUser){this.num=num;this.numberProvided=providedByUser;}toString(){return JSON.stringify(this);}static revive(playerToRevive){return this.reviveRecursive(playerToRevive,false);}static reviveRecursive(playerToRevive,isPlayerLink){let revivedPosition=Position.revive(playerToRevive.playerType);let revivedPlayer=new Player(playerToRevive.name,revivedPosition,playerToRevive.currentPosition);revivedPlayer.setInRotation(playerToRevive.usedInRotation);revivedPlayer.setNumber(playerToRevive.num);revivedPlayer.setServe(playerToRevive.serve);if(!isPlayerLink&&playerToRevive.playerLink!==undefined){revivedPlayer.setPlayerLink(this.reviveRecursive(playerToRevive.playerLink,true));}return revivedPlayer;}}","map":{"version":3,"names":["Position","Player","constructor","name","playerType","currentPosition","usedInRotation","playerLink","serve","num","numberProvided","hasPlayerLink","undefined","setName","getName","setPlayerType","getPlayerType","setCurrentPosition","getCurrentPosition","setInRotation","value","isInRotation","setServe","willServe","isServing","getPlayerLink","setPlayerLink","player","getNumber","setNumber","setPlayerNumber","providedByUser","toString","JSON","stringify","revive","playerToRevive","reviveRecursive","isPlayerLink","revivedPosition","revivedPlayer"],"sources":["/Users/adamhayes/RotationHelper/src/components/Player.tsx"],"sourcesContent":["import { Position } from \"../enums/Position\";\n\nexport class Player {\n    name: String;\n    playerType: Position;\n    currentPosition: number;\n    usedInRotation: boolean = false;\n    playerLink: Player;\n    serve: boolean = true;\n    num:number;\n    numberProvided: boolean = false;\n    //TODO: implement (optional) player number, if the field was filled out on creation, then display that info.\n    //otherwise, auto-increment the player id starting from the lowest available number on the current team\n\n\n    //  id:number;\n    //TODO use mongoDB for player ids, like i did for chess games\n\n    constructor(name: String, playerType: Position, currentPosition: number) {\n        //todo: figure out currentPosition value, is it like player number? or is it like, rotation location?\n        this.name = name;\n        this.playerType = playerType;\n        this.currentPosition = currentPosition;\n    }\n\n    /**\n     * hasPlayerLink defines a substitution connection between this player and a different player. The Position type of the player object\n     * will be used to determine what occurs when this player rotates/transitions between the front and back rows\n     */\n    public hasPlayerLink(): boolean {\n        return this.playerLink !== undefined;\n    }\n\n    public setName(name: String) {\n        this.name = name;\n    }\n    public getName(): String {\n        return this.name;\n    }\n\n    public setPlayerType(playerType: Position) {\n        this.playerType = playerType;\n    }\n\n    public getPlayerType(): Position {\n        return this.playerType;\n    }\n\n\n    //rotation position\n    public setCurrentPosition(currentPosition: number) {\n        this.currentPosition = currentPosition;\n    }\n\n    public getCurrentPosition(): number {\n        return this.currentPosition;\n    }\n\n    public setInRotation(value: boolean) {\n        this.usedInRotation = value;\n    }\n\n    public isInRotation(): boolean {\n        return this.usedInRotation;\n    }\n\n    public setServe(willServe: boolean) {\n        this.serve = willServe;\n    }\n\n    public isServing(): boolean {\n        return this.serve;\n    }\n\n    public getPlayerLink():Player | undefined {\n        return this.playerLink;\n    }\n\n    public setPlayerLink(player:Player)\n    {\n        this.playerLink = player;\n    }\n\n    public getNumber():number {\n        return this.num;\n    }\n\n    public setNumber(num:number) {\n        this.num = num;\n    }\n\n\n    public setPlayerNumber(num:number, providedByUser:boolean)\n    {\n        this.num = num;\n        this.numberProvided = providedByUser;\n    }\n\n    public toString():string {\n        return JSON.stringify(this);\n    }\n\n\n    public static revive(playerToRevive:Player):Player {\n\n        return this.reviveRecursive(playerToRevive, false);\n    }\n\n    private static reviveRecursive(playerToRevive:Player, isPlayerLink:boolean):Player\n    {\n        let revivedPosition = Position.revive(playerToRevive.playerType);\n        let revivedPlayer = new Player(playerToRevive.name, revivedPosition, playerToRevive.currentPosition);\n        revivedPlayer.setInRotation(playerToRevive.usedInRotation);\n        revivedPlayer.setNumber(playerToRevive.num);\n        revivedPlayer.setServe(playerToRevive.serve);\n        if (!isPlayerLink && playerToRevive.playerLink !== undefined) {\n            revivedPlayer.setPlayerLink(this.reviveRecursive(playerToRevive.playerLink, true));\n        }\n        return revivedPlayer;\n    }\n\n\n\n}"],"mappings":"AAAA,OAASA,QAAQ,KAAQ,mBAAmB,CAE5C,MAAO,MAAM,CAAAC,MAAO,CAShB;AACA;AAGA;AACA;AAEAC,WAAWA,CAACC,IAAY,CAAEC,UAAoB,CAAEC,eAAuB,CAAE,MAfzEF,IAAI,aACJC,UAAU,aACVC,eAAe,aACfC,cAAc,CAAY,KAAK,MAC/BC,UAAU,aACVC,KAAK,CAAY,IAAI,MACrBC,GAAG,aACHC,cAAc,CAAY,KAAK,CAS3B;AACA,IAAI,CAACP,IAAI,CAAGA,IAAI,CAChB,IAAI,CAACC,UAAU,CAAGA,UAAU,CAC5B,IAAI,CAACC,eAAe,CAAGA,eAAe,CAC1C,CAEA;AACJ;AACA;AACA,OACWM,aAAaA,CAAA,CAAY,CAC5B,MAAO,KAAI,CAACJ,UAAU,GAAKK,SAAS,CACxC,CAEOC,OAAOA,CAACV,IAAY,CAAE,CACzB,IAAI,CAACA,IAAI,CAAGA,IAAI,CACpB,CACOW,OAAOA,CAAA,CAAW,CACrB,MAAO,KAAI,CAACX,IAAI,CACpB,CAEOY,aAAaA,CAACX,UAAoB,CAAE,CACvC,IAAI,CAACA,UAAU,CAAGA,UAAU,CAChC,CAEOY,aAAaA,CAAA,CAAa,CAC7B,MAAO,KAAI,CAACZ,UAAU,CAC1B,CAGA;AACOa,kBAAkBA,CAACZ,eAAuB,CAAE,CAC/C,IAAI,CAACA,eAAe,CAAGA,eAAe,CAC1C,CAEOa,kBAAkBA,CAAA,CAAW,CAChC,MAAO,KAAI,CAACb,eAAe,CAC/B,CAEOc,aAAaA,CAACC,KAAc,CAAE,CACjC,IAAI,CAACd,cAAc,CAAGc,KAAK,CAC/B,CAEOC,YAAYA,CAAA,CAAY,CAC3B,MAAO,KAAI,CAACf,cAAc,CAC9B,CAEOgB,QAAQA,CAACC,SAAkB,CAAE,CAChC,IAAI,CAACf,KAAK,CAAGe,SAAS,CAC1B,CAEOC,SAASA,CAAA,CAAY,CACxB,MAAO,KAAI,CAAChB,KAAK,CACrB,CAEOiB,aAAaA,CAAA,CAAsB,CACtC,MAAO,KAAI,CAAClB,UAAU,CAC1B,CAEOmB,aAAaA,CAACC,MAAa,CAClC,CACI,IAAI,CAACpB,UAAU,CAAGoB,MAAM,CAC5B,CAEOC,SAASA,CAAA,CAAU,CACtB,MAAO,KAAI,CAACnB,GAAG,CACnB,CAEOoB,SAASA,CAACpB,GAAU,CAAE,CACzB,IAAI,CAACA,GAAG,CAAGA,GAAG,CAClB,CAGOqB,eAAeA,CAACrB,GAAU,CAAEsB,cAAsB,CACzD,CACI,IAAI,CAACtB,GAAG,CAAGA,GAAG,CACd,IAAI,CAACC,cAAc,CAAGqB,cAAc,CACxC,CAEOC,QAAQA,CAAA,CAAU,CACrB,MAAO,CAAAC,IAAI,CAACC,SAAS,CAAC,IAAI,CAAC,CAC/B,CAGA,MAAc,CAAAC,MAAMA,CAACC,cAAqB,CAAS,CAE/C,MAAO,KAAI,CAACC,eAAe,CAACD,cAAc,CAAE,KAAK,CAAC,CACtD,CAEA,MAAe,CAAAC,eAAeA,CAACD,cAAqB,CAAEE,YAAoB,CAC1E,CACI,GAAI,CAAAC,eAAe,CAAGvC,QAAQ,CAACmC,MAAM,CAACC,cAAc,CAAChC,UAAU,CAAC,CAChE,GAAI,CAAAoC,aAAa,CAAG,GAAI,CAAAvC,MAAM,CAACmC,cAAc,CAACjC,IAAI,CAAEoC,eAAe,CAAEH,cAAc,CAAC/B,eAAe,CAAC,CACpGmC,aAAa,CAACrB,aAAa,CAACiB,cAAc,CAAC9B,cAAc,CAAC,CAC1DkC,aAAa,CAACX,SAAS,CAACO,cAAc,CAAC3B,GAAG,CAAC,CAC3C+B,aAAa,CAAClB,QAAQ,CAACc,cAAc,CAAC5B,KAAK,CAAC,CAC5C,GAAI,CAAC8B,YAAY,EAAIF,cAAc,CAAC7B,UAAU,GAAKK,SAAS,CAAE,CAC1D4B,aAAa,CAACd,aAAa,CAAC,IAAI,CAACW,eAAe,CAACD,cAAc,CAAC7B,UAAU,CAAE,IAAI,CAAC,CAAC,CACtF,CACA,MAAO,CAAAiC,aAAa,CACxB,CAIJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}